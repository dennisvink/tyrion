#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>

typedef struct List List;
typedef struct Tuple Tuple;
typedef struct Dict Dict;
typedef struct Set Set;
typedef struct File File;
typedef struct Function Function;
typedef struct Class Class;
typedef struct Instance Instance;
typedef struct Bound Bound;
typedef struct ExcFrame ExcFrame;

typedef enum { VAL_INT, VAL_FLOAT, VAL_STR, VAL_BOOL, VAL_LIST, VAL_TUPLE, VAL_DICT, VAL_SET, VAL_FILE, VAL_FUNC, VAL_CLASS, VAL_INSTANCE, VAL_BOUND } Tag;

typedef struct Value {
    Tag tag;
    union {
        long long i;
        double f;
        char* s;
        int b;
        List* list;
        Tuple* tuple;
        Dict* dict;
        Set* setv;
        struct File* file;
        struct Function* func;
        struct Class* cls;
        struct Instance* inst;
        struct Bound* bound;
    } as;
} Value;

struct List {
    size_t len;
    size_t cap;
    Value* items;
};

struct Tuple {
    size_t len;
    Value* items;
};

typedef struct {
    Value key;
    Value value;
    int used;
} DictEntry;

struct Dict {
    size_t len;
    size_t cap;
    DictEntry* entries;
};

typedef struct {
    Value key;
    int used;
} SetEntry;

struct Set {
    size_t len;
    size_t cap;
    SetEntry* entries;
};

struct File {
    FILE* handle;
    int closed;
    int refs;
};

struct Class {
    char* name;
    Dict* methods;
    int refs;
};

struct Instance {
    Class* cls;
    Dict* fields;
    int refs;
};

struct Bound {
    Instance* inst;
    Value func;
    int refs;
};

typedef Value (*FuncPtr)(int argc, Value* args);
struct Function {
    FuncPtr ptr;
    int refs;
};

static Value value_call(Value func, int argc, Value* args);
static Value value_bound(Instance* inst, Value func);
static Value value_list_append(Value obj, Value arg);
static Value value_list_remove(Value obj, Value arg);
static Value value_set_add(Value obj, Value arg);
static Value value_dict_items(Value obj);
static Value value_dict_keys(Value obj);
static Value value_file_read(Value obj);
static Value value_file_write(Value obj, Value arg);
static Value value_get_attr(Value obj, const char* name);
static void value_set_attr(Value obj, const char* name, Value val);
static Value value_method_call(Value obj, const char* name, int argc, Value* args);

struct ExcFrame {
    jmp_buf buf;
    struct ExcFrame* prev;
};

static ExcFrame* exc_stack = NULL;
static int exc_active = 0;
static Value exc_value;

static void* xmalloc(size_t n) {
    void* p = malloc(n);
    if (!p) {
        fprintf(stderr, "out of memory\n");
        exit(1);
    }
    return p;
}

static Value value_int(long long v) {
    Value x; x.tag = VAL_INT; x.as.i = v; return x;
}
static Value value_float(double v) {
    Value x; x.tag = VAL_FLOAT; x.as.f = v; return x;
}
static Value value_str(const char* v) {
    Value x; x.tag = VAL_STR; size_t n = strlen(v); x.as.s = (char*)xmalloc(n + 1); memcpy(x.as.s, v, n + 1); return x;
}
static Value value_bool(int b) {
    Value x; x.tag = VAL_BOOL; x.as.b = b ? 1 : 0; return x;
}
static Value value_list_literal(size_t len, Value* items);
static Value value_tuple_literal(size_t len, Value* items);
static Value value_dict_literal(size_t len, Value* keys, Value* values);
static Value value_set_literal(size_t len, Value* items);
static Value value_str_from_value(Value v);

static int value_eq(Value a, Value b) {
    if ((a.tag == VAL_INT || a.tag == VAL_FLOAT || a.tag == VAL_BOOL) &&
        (b.tag == VAL_INT || b.tag == VAL_FLOAT || b.tag == VAL_BOOL)) {
        double av = (a.tag == VAL_FLOAT) ? a.as.f : (a.tag == VAL_BOOL ? (double)a.as.b : (double)a.as.i);
        double bv = (b.tag == VAL_FLOAT) ? b.as.f : (b.tag == VAL_BOOL ? (double)b.as.b : (double)b.as.i);
        return av == bv;
    }
    if (a.tag == VAL_STR && b.tag == VAL_STR) {
        return strcmp(a.as.s, b.as.s) == 0;
    }
    return 0;
}

static Value value_clone(Value v) {
    switch (v.tag) {
        case VAL_STR:
            return value_str(v.as.s);
        case VAL_FILE: {
            if (v.as.file) v.as.file->refs += 1;
            return v;
        }
        case VAL_FUNC: {
            if (v.as.func) v.as.func->refs += 1;
            return v;
        }
        case VAL_CLASS: {
            if (v.as.cls) v.as.cls->refs += 1;
            return v;
        }
        case VAL_INSTANCE: {
            if (v.as.inst) v.as.inst->refs += 1;
            return v;
        }
        case VAL_BOUND: {
            if (v.as.bound) v.as.bound->refs += 1;
            return v;
        }
        case VAL_LIST: {
            List* src = v.as.list;
            List* l = (List*)xmalloc(sizeof(List));
            l->len = src ? src->len : 0;
            l->cap = l->len ? l->len : 4;
            l->items = (Value*)xmalloc(l->cap * sizeof(Value));
            for (size_t i = 0; i < l->len; i++) {
                l->items[i] = value_clone(src->items[i]);
            }
            Value r; r.tag = VAL_LIST; r.as.list = l; return r;
        }
        case VAL_TUPLE: {
            Tuple* src = v.as.tuple;
            Tuple* t = (Tuple*)xmalloc(sizeof(Tuple));
            t->len = src ? src->len : 0;
            t->items = t->len ? (Value*)xmalloc(t->len * sizeof(Value)) : NULL;
            for (size_t i = 0; i < t->len; i++) {
                t->items[i] = value_clone(src->items[i]);
            }
            Value r; r.tag = VAL_TUPLE; r.as.tuple = t; return r;
        }
        case VAL_DICT: {
            Dict* src = v.as.dict;
            Dict* d = (Dict*)xmalloc(sizeof(Dict));
            d->len = src ? src->len : 0;
            d->cap = d->len;
            d->entries = d->cap ? (DictEntry*)xmalloc(d->cap * sizeof(DictEntry)) : NULL;
            for (size_t i = 0; i < d->len; i++) {
                d->entries[i].used = src->entries[i].used;
                if (src->entries[i].used) {
                    d->entries[i].key = value_clone(src->entries[i].key);
                    d->entries[i].value = value_clone(src->entries[i].value);
                }
            }
            Value r; r.tag = VAL_DICT; r.as.dict = d; return r;
        }
        case VAL_SET: {
            Set* src = v.as.setv;
            Set* s = (Set*)xmalloc(sizeof(Set));
            s->len = src ? src->len : 0;
            s->cap = s->len;
            s->entries = s->cap ? (SetEntry*)xmalloc(s->cap * sizeof(SetEntry)) : NULL;
            for (size_t i = 0; i < s->len; i++) {
                s->entries[i].used = src->entries[i].used;
                if (src->entries[i].used) {
                    s->entries[i].key = value_clone(src->entries[i].key);
                }
            }
            Value r; r.tag = VAL_SET; r.as.setv = s; return r;
        }
        default:
            return v;
    }
}

static void value_free(Value v) {
    switch (v.tag) {
        case VAL_STR:
            if (v.as.s) free(v.as.s);
            break;
        case VAL_LIST:
            if (v.as.list) {
                for (size_t i = 0; i < v.as.list->len; i++) value_free(v.as.list->items[i]);
                free(v.as.list->items);
                free(v.as.list);
            }
            break;
        case VAL_TUPLE:
            if (v.as.tuple) {
                for (size_t i = 0; i < v.as.tuple->len; i++) value_free(v.as.tuple->items[i]);
                free(v.as.tuple->items);
                free(v.as.tuple);
            }
            break;
        case VAL_DICT:
            if (v.as.dict) {
                for (size_t i = 0; i < v.as.dict->len; i++) {
                    if (v.as.dict->entries[i].used) {
                        value_free(v.as.dict->entries[i].key);
                        value_free(v.as.dict->entries[i].value);
                    }
                }
                free(v.as.dict->entries);
                free(v.as.dict);
            }
            break;
        case VAL_SET:
            if (v.as.setv) {
                for (size_t i = 0; i < v.as.setv->len; i++) {
                    if (v.as.setv->entries[i].used) {
                        value_free(v.as.setv->entries[i].key);
                    }
                }
                free(v.as.setv->entries);
                free(v.as.setv);
            }
            break;
        case VAL_FILE:
            if (v.as.file) {
                v.as.file->refs -= 1;
                if (v.as.file->refs == 0) {
                    if (!v.as.file->closed && v.as.file->handle) {
                        fclose(v.as.file->handle);
                    }
                    free(v.as.file);
                }
            }
            break;
        case VAL_FUNC:
            if (v.as.func) {
                v.as.func->refs -= 1;
                if (v.as.func->refs == 0) {
                    free(v.as.func);
                }
            }
            break;
        case VAL_CLASS:
            if (v.as.cls) {
                v.as.cls->refs -= 1;
                if (v.as.cls->refs == 0) {
                    if (v.as.cls->name) free(v.as.cls->name);
                    if (v.as.cls->methods) {
                        for (size_t i = 0; i < v.as.cls->methods->len; i++) {
                            if (v.as.cls->methods->entries[i].used) {
                                value_free(v.as.cls->methods->entries[i].key);
                                value_free(v.as.cls->methods->entries[i].value);
                            }
                        }
                        free(v.as.cls->methods->entries);
                        free(v.as.cls->methods);
                    }
                    free(v.as.cls);
                }
            }
            break;
        case VAL_INSTANCE:
            if (v.as.inst) {
                v.as.inst->refs -= 1;
                if (v.as.inst->refs == 0) {
                    if (v.as.inst->cls) {
                        Value c; c.tag = VAL_CLASS; c.as.cls = v.as.inst->cls; value_free(c);
                    }
                    if (v.as.inst->fields) {
                        for (size_t i = 0; i < v.as.inst->fields->len; i++) {
                            if (v.as.inst->fields->entries[i].used) {
                                value_free(v.as.inst->fields->entries[i].key);
                                value_free(v.as.inst->fields->entries[i].value);
                            }
                        }
                        free(v.as.inst->fields->entries);
                        free(v.as.inst->fields);
                    }
                    free(v.as.inst);
                }
            }
            break;
        case VAL_BOUND:
            if (v.as.bound) {
                v.as.bound->refs -= 1;
                if (v.as.bound->refs == 0) {
                    value_free(v.as.bound->func);
                    if (v.as.bound->inst) {
                        Value tmp; tmp.tag = VAL_INSTANCE; tmp.as.inst = v.as.bound->inst; value_free(tmp);
                    }
                    free(v.as.bound);
                }
            }
            break;
        default:
            break;
    }
}

static void list_ensure(List* l, size_t need) {
    if (need <= l->cap) return;
    size_t cap = l->cap ? l->cap : 4;
    while (cap < need) cap *= 2;
    Value* items = (Value*)realloc(l->items, cap * sizeof(Value));
    if (!items) { fprintf(stderr, "out of memory\n"); exit(1); }
    l->items = items;
    l->cap = cap;
}

static void dict_ensure(Dict* d, size_t need) {
    if (need <= d->cap) return;
    size_t cap = d->cap ? d->cap * 2 : (need ? need : 4);
    DictEntry* e = (DictEntry*)realloc(d->entries, cap * sizeof(DictEntry));
    if (!e) { fprintf(stderr, "out of memory\n"); exit(1); }
    d->entries = e;
    for (size_t i = d->cap; i < cap; i++) {
        d->entries[i].used = 0;
    }
    d->cap = cap;
}

static void set_ensure(Set* s, size_t need) {
    if (need <= s->cap) return;
    size_t cap = s->cap ? s->cap * 2 : (need ? need : 4);
    SetEntry* e = (SetEntry*)realloc(s->entries, cap * sizeof(SetEntry));
    if (!e) { fprintf(stderr, "out of memory\n"); exit(1); }
    s->entries = e;
    for (size_t i = s->cap; i < cap; i++) {
        s->entries[i].used = 0;
    }
    s->cap = cap;
}

static Value value_list_literal(size_t len, Value* items) {
    List* l = (List*)xmalloc(sizeof(List));
    l->len = len;
    l->cap = len ? len : 4;
    l->items = (Value*)xmalloc(l->cap * sizeof(Value));
    for (size_t i = 0; i < len; i++) l->items[i] = value_clone(items[i]);
    Value v; v.tag = VAL_LIST; v.as.list = l; return v;
}

static Value value_tuple_literal(size_t len, Value* items) {
    Tuple* t = (Tuple*)xmalloc(sizeof(Tuple));
    t->len = len;
    t->items = len ? (Value*)xmalloc(len * sizeof(Value)) : NULL;
    for (size_t i = 0; i < len; i++) t->items[i] = value_clone(items[i]);
    Value v; v.tag = VAL_TUPLE; v.as.tuple = t; return v;
}

static Value value_dict_literal(size_t len, Value* keys, Value* values) {
    Dict* d = (Dict*)xmalloc(sizeof(Dict));
    d->len = 0;
    d->cap = len ? len : 1;
    d->entries = d->cap ? (DictEntry*)xmalloc(d->cap * sizeof(DictEntry)) : NULL;
    for (size_t i = 0; i < d->cap; i++) d->entries[i].used = 0;
    for (size_t i = 0; i < len; i++) {
        // reuse set logic to keep unique keys
        int found = 0;
        for (size_t j = 0; j < d->len; j++) {
            if (d->entries[j].used && value_eq(d->entries[j].key, keys[i])) {
                value_free(d->entries[j].value);
                d->entries[j].value = value_clone(values[i]);
                found = 1;
                break;
            }
        }
        if (!found) {
            dict_ensure(d, d->len + 1);
            d->entries[d->len].used = 1;
            d->entries[d->len].key = value_clone(keys[i]);
            d->entries[d->len].value = value_clone(values[i]);
            d->len += 1;
        }
    }
    Value v; v.tag = VAL_DICT; v.as.dict = d; return v;
}

static Value value_set_literal(size_t len, Value* items) {
    Set* s = (Set*)xmalloc(sizeof(Set));
    s->len = 0;
    s->cap = len ? len : 1;
    s->entries = s->cap ? (SetEntry*)xmalloc(s->cap * sizeof(SetEntry)) : NULL;
    for (size_t i = 0; i < s->cap; i++) s->entries[i].used = 0;
    for (size_t i = 0; i < len; i++) {
        int exists = 0;
        for (size_t j = 0; j < s->len; j++) {
            if (s->entries[j].used && value_eq(s->entries[j].key, items[i])) {
                exists = 1; break;
            }
        }
        if (!exists) {
            set_ensure(s, s->len + 1);
            s->entries[s->len].used = 1;
            s->entries[s->len].key = value_clone(items[i]);
            s->len += 1;
        }
    }
    Value v; v.tag = VAL_SET; v.as.setv = s; return v;
}

static Value value_clone_list_data(List* l) {
    return value_list_literal(l ? l->len : 0, l ? l->items : NULL);
}

static Value value_add(Value a, Value b) {
    if (a.tag == VAL_STR || b.tag == VAL_STR) {
        Value sa = (a.tag == VAL_STR) ? value_clone(a) : value_str_from_value(a);
        Value sb = (b.tag == VAL_STR) ? value_clone(b) : value_str_from_value(b);
        size_t la = strlen(sa.as.s), lb = strlen(sb.as.s);
        char* buf = (char*)xmalloc(la + lb + 1);
        memcpy(buf, sa.as.s, la);
        memcpy(buf + la, sb.as.s, lb + 1);
        value_free(sa); value_free(sb);
        Value r = value_str("");
        free(r.as.s);
        r.as.s = buf;
        return r;
    }
    if (a.tag == VAL_LIST && b.tag == VAL_LIST) {
        List* la = a.as.list; List* lb = b.as.list;
        size_t total = (la ? la->len : 0) + (lb ? lb->len : 0);
        Value res = value_list_literal(0, NULL);
        list_ensure(res.as.list, total);
        res.as.list->len = total;
        size_t idx = 0;
        if (la) {
            for (size_t i = 0; i < la->len; i++) res.as.list->items[idx++] = value_clone(la->items[i]);
        }
        if (lb) {
            for (size_t i = 0; i < lb->len; i++) res.as.list->items[idx++] = value_clone(lb->items[i]);
        }
        return res;
    }
    if (a.tag == VAL_FLOAT || b.tag == VAL_FLOAT || a.tag == VAL_BOOL || b.tag == VAL_BOOL) {
        double av = (a.tag == VAL_FLOAT) ? a.as.f : (double)(a.tag == VAL_BOOL ? a.as.b : a.as.i);
        double bv = (b.tag == VAL_FLOAT) ? b.as.f : (double)(b.tag == VAL_BOOL ? b.as.b : b.as.i);
        return value_float(av + bv);
    }
    if (a.tag == VAL_INT && b.tag == VAL_INT) {
        return value_int(a.as.i + b.as.i);
    }
    fprintf(stderr, "Type error: unsupported operands for +\n"); exit(1);
}

static Value value_sub(Value a, Value b) {
    double av = (a.tag == VAL_FLOAT) ? a.as.f : (double)a.as.i;
    double bv = (b.tag == VAL_FLOAT) ? b.as.f : (double)b.as.i;
    return (a.tag == VAL_INT && b.tag == VAL_INT) ? value_int((long long)(av - bv)) : value_float(av - bv);
}

static Value value_mul(Value a, Value b) {
    double av = (a.tag == VAL_FLOAT) ? a.as.f : (double)a.as.i;
    double bv = (b.tag == VAL_FLOAT) ? b.as.f : (double)b.as.i;
    return (a.tag == VAL_INT && b.tag == VAL_INT) ? value_int((long long)(av * bv)) : value_float(av * bv);
}

static Value value_div(Value a, Value b) {
    double av = (a.tag == VAL_FLOAT) ? a.as.f : (double)a.as.i;
    double bv = (b.tag == VAL_FLOAT) ? b.as.f : (double)b.as.i;
    if (bv == 0) { fprintf(stderr, "division by zero\n"); exit(1); }
    return value_float(av / bv);
}

static Value value_neg(Value a) {
    if (a.tag == VAL_FLOAT) return value_float(-a.as.f);
    if (a.tag == VAL_INT) return value_int(-a.as.i);
    fprintf(stderr, "Type error: unary - on non-number\n"); exit(1);
}

static Value value_cmp(Value a, Value b, int op) {
    int result = 0;
    if ((a.tag == VAL_STR && b.tag == VAL_STR)) {
        int cmp = strcmp(a.as.s, b.as.s);
        switch (op) {
            case 0: result = cmp == 0; break;
            case 1: result = cmp != 0; break;
            case 2: result = cmp < 0; break;
            case 3: result = cmp <= 0; break;
            case 4: result = cmp > 0; break;
            case 5: result = cmp >= 0; break;
        }
    } else if ((a.tag == VAL_INT || a.tag == VAL_FLOAT || a.tag == VAL_BOOL) &&
               (b.tag == VAL_INT || b.tag == VAL_FLOAT || b.tag == VAL_BOOL)) {
        double av = (a.tag == VAL_FLOAT) ? a.as.f : (a.tag == VAL_BOOL ? (double)a.as.b : (double)a.as.i);
        double bv = (b.tag == VAL_FLOAT) ? b.as.f : (b.tag == VAL_BOOL ? (double)b.as.b : (double)b.as.i);
        switch (op) {
            case 0: result = av == bv; break;
            case 1: result = av != bv; break;
            case 2: result = av < bv; break;
            case 3: result = av <= bv; break;
            case 4: result = av > bv; break;
            case 5: result = av >= bv; break;
        }
    } else {
        fprintf(stderr, "Type error: incompatible types for comparison\n"); exit(1);
    }
    return value_bool(result);
}

static int value_lt(Value a, Value b) {
    if (a.tag == VAL_STR && b.tag == VAL_STR) {
        return strcmp(a.as.s, b.as.s) < 0;
    }
    if ((a.tag == VAL_INT || a.tag == VAL_FLOAT || a.tag == VAL_BOOL) &&
        (b.tag == VAL_INT || b.tag == VAL_FLOAT || b.tag == VAL_BOOL)) {
        double av = (a.tag == VAL_FLOAT) ? a.as.f : (a.tag == VAL_BOOL ? (double)a.as.b : (double)a.as.i);
        double bv = (b.tag == VAL_FLOAT) ? b.as.f : (b.tag == VAL_BOOL ? (double)b.as.b : (double)b.as.i);
        return av < bv;
    }
    fprintf(stderr, "Type error: cannot compare values for sorting\n");
    exit(1);
}

static int value_truthy(Value v) {
    switch (v.tag) {
        case VAL_BOOL: return v.as.b != 0;
        case VAL_INT: return v.as.i != 0;
        case VAL_FLOAT: return v.as.f != 0.0;
        case VAL_STR: return v.as.s && strlen(v.as.s) > 0;
        case VAL_LIST: return v.as.list && v.as.list->len > 0;
        case VAL_TUPLE: return v.as.tuple && v.as.tuple->len > 0;
        case VAL_DICT: return v.as.dict && v.as.dict->len > 0;
        case VAL_SET: return v.as.setv && v.as.setv->len > 0;
        case VAL_FILE: return v.as.file && !v.as.file->closed;
        case VAL_FUNC: return 1;
        case VAL_CLASS: return 1;
        case VAL_INSTANCE: return 1;
        case VAL_BOUND: return 1;
    }
    return 0;
}

static Value value_not(Value v) {
    Value r = value_bool(!value_truthy(v));
    return r;
}

static long long value_to_index(Value v) {
    if (v.tag == VAL_INT) return v.as.i;
    if (v.tag == VAL_BOOL) return (long long)v.as.b;
    if (v.tag == VAL_FLOAT) return (long long)v.as.f;
    fprintf(stderr, "Type error: index must be int\n"); exit(1);
}

static Value dict_get(Dict* d, Value key) {
    for (size_t i = 0; i < d->len; i++) {
        if (d->entries[i].used && value_eq(d->entries[i].key, key)) {
            return value_clone(d->entries[i].value);
        }
    }
    fprintf(stderr, "KeyError in dict lookup\n"); exit(1);
}

static void dict_set(Dict* d, Value key, Value val) {
    for (size_t i = 0; i < d->len; i++) {
        if (d->entries[i].used && value_eq(d->entries[i].key, key)) {
            value_free(d->entries[i].value);
            d->entries[i].value = value_clone(val);
            return;
        }
    }
    dict_ensure(d, d->len + 1);
    d->entries[d->len].used = 1;
    d->entries[d->len].key = value_clone(key);
    d->entries[d->len].value = value_clone(val);
    d->len += 1;
}

static int set_contains(Set* s, Value key) {
    for (size_t i = 0; i < s->len; i++) {
        if (s->entries[i].used && value_eq(s->entries[i].key, key)) return 1;
    }
    return 0;
}

static Value value_index(Value obj, Value idx) {
    if (obj.tag == VAL_LIST) {
        List* l = obj.as.list;
        long long pos = value_to_index(idx);
        if (pos < 0) pos += (long long)l->len;
        if (pos < 0 || (size_t)pos >= l->len) { fprintf(stderr, "list index out of range\n"); exit(1); }
        return value_clone(l->items[pos]);
    }
    if (obj.tag == VAL_TUPLE) {
        Tuple* t = obj.as.tuple;
        long long pos = value_to_index(idx);
        if (pos < 0) pos += (long long)t->len;
        if (pos < 0 || (size_t)pos >= t->len) { fprintf(stderr, "tuple index out of range\n"); exit(1); }
        return value_clone(t->items[pos]);
    }
    if (obj.tag == VAL_STR) {
        long long pos = value_to_index(idx);
        size_t len = strlen(obj.as.s);
        if (pos < 0) pos += (long long)len;
        if (pos < 0 || (size_t)pos >= len) { fprintf(stderr, "string index out of range\n"); exit(1); }
        char buf[2] = { obj.as.s[pos], '\0' };
        return value_str(buf);
    }
    if (obj.tag == VAL_DICT) {
        return dict_get(obj.as.dict, idx);
    }
    fprintf(stderr, "Type error: indexing non-container\n"); exit(1);
}

static void value_set_item(Value obj, Value idx, Value val) {
    if (obj.tag == VAL_LIST) {
        List* l = obj.as.list;
        long long pos = value_to_index(idx);
        if (pos < 0) pos += (long long)l->len;
        if (pos < 0 || (size_t)pos >= l->len) { fprintf(stderr, "list assignment index out of range\n"); exit(1); }
        value_free(l->items[pos]);
        l->items[pos] = value_clone(val);
        return;
    }
    if (obj.tag == VAL_DICT) {
        dict_set(obj.as.dict, idx, val);
        return;
    }
    fprintf(stderr, "Type error: cannot assign to this subscript\n"); exit(1);
}

static Value value_get_attr(Value obj, const char* name) {
    if (obj.tag == VAL_INSTANCE && obj.as.inst) {
        Value key = value_str(name);
        for (size_t i = 0; i < obj.as.inst->fields->len; i++) {
            if (obj.as.inst->fields->entries[i].used && value_eq(obj.as.inst->fields->entries[i].key, key)) {
                Value v = value_clone(obj.as.inst->fields->entries[i].value);
                value_free(key);
                return v;
            }
        }
        if (obj.as.inst->cls && obj.as.inst->cls->methods) {
            for (size_t i = 0; i < obj.as.inst->cls->methods->len; i++) {
                if (obj.as.inst->cls->methods->entries[i].used &&
                    value_eq(obj.as.inst->cls->methods->entries[i].key, key)) {
                    Value b = value_bound(obj.as.inst, obj.as.inst->cls->methods->entries[i].value);
                    value_free(key);
                    return b;
                }
            }
        }
        value_free(key);
        fprintf(stderr, "AttributeError: %s\n", name);
        exit(1);
    }
    if (obj.tag == VAL_CLASS && obj.as.cls) {
        Value key = value_str(name);
        for (size_t i = 0; i < obj.as.cls->methods->len; i++) {
            if (obj.as.cls->methods->entries[i].used && value_eq(obj.as.cls->methods->entries[i].key, key)) {
                Value v = value_clone(obj.as.cls->methods->entries[i].value);
                value_free(key);
                return v;
            }
        }
        value_free(key);
        fprintf(stderr, "AttributeError: %s\n", name);
        exit(1);
    }
    fprintf(stderr, "AttributeError: unsupported attribute access\n");
    exit(1);
}

static void value_set_attr(Value obj, const char* name, Value val) {
    if (obj.tag == VAL_INSTANCE && obj.as.inst) {
        Value key = value_str(name);
        dict_set(obj.as.inst->fields, key, val);
        value_free(key);
        return;
    }
    if (obj.tag == VAL_CLASS && obj.as.cls) {
        Value key = value_str(name);
        dict_set(obj.as.cls->methods, key, val);
        value_free(key);
        return;
    }
    fprintf(stderr, "Type error: cannot set attribute on this object\n");
    exit(1);
}

static Value value_method_call(Value obj, const char* name, int argc, Value* args) {
    // built-in methods on collections/files
    if (obj.tag == VAL_LIST) {
        if (strcmp(name, "append") == 0) {
            if (argc != 1) { fprintf(stderr, "append expects 1 arg\n"); exit(1); }
            return value_list_append(obj, args[0]);
        }
        if (strcmp(name, "remove") == 0) {
            if (argc != 1) { fprintf(stderr, "remove expects 1 arg\n"); exit(1); }
            return value_list_remove(obj, args[0]);
        }
    }
    if (obj.tag == VAL_SET) {
        if (strcmp(name, "add") == 0) {
            if (argc != 1) { fprintf(stderr, "add expects 1 arg\n"); exit(1); }
            return value_set_add(obj, args[0]);
        }
    }
    if (obj.tag == VAL_DICT) {
        if (strcmp(name, "items") == 0) {
            if (argc != 0) { fprintf(stderr, "items expects 0 args\n"); exit(1); }
            return value_dict_items(obj);
        }
        if (strcmp(name, "keys") == 0) {
            if (argc != 0) { fprintf(stderr, "keys expects 0 args\n"); exit(1); }
            return value_dict_keys(obj);
        }
    }
    if (obj.tag == VAL_FILE) {
        if (strcmp(name, "read") == 0) {
            if (argc != 0) { fprintf(stderr, "read expects 0 args\n"); exit(1); }
            return value_file_read(obj);
        }
        if (strcmp(name, "write") == 0) {
            if (argc != 1) { fprintf(stderr, "write expects 1 arg\n"); exit(1); }
            return value_file_write(obj, args[0]);
        }
    }
    Value attr = value_get_attr(obj, name);
    Value res = value_call(attr, argc, args);
    value_free(attr);
    return res;
}

static Value value_slice(Value obj, Value* start_opt, int has_start, Value* end_opt, int has_end) {
    long long start = has_start ? value_to_index(*start_opt) : 0;
    if (obj.tag == VAL_STR) {
        size_t len = strlen(obj.as.s);
        long long end = has_end ? value_to_index(*end_opt) : (long long)len;
        if (start < 0) start += (long long)len;
        if (end < 0) end += (long long)len;
        if (start < 0) start = 0;
        if (end < start) end = start;
        if ((size_t)end > len) end = (long long)len;
        size_t n = (size_t)(end - start);
        char* buf = (char*)xmalloc(n + 1);
        memcpy(buf, obj.as.s + start, n);
        buf[n] = '\0';
        Value r = value_str("");
        free(r.as.s);
        r.as.s = buf;
        return r;
    }
    if (obj.tag == VAL_LIST) {
        List* l = obj.as.list;
        size_t len = l->len;
        long long end = has_end ? value_to_index(*end_opt) : (long long)len;
        if (start < 0) start += (long long)len;
        if (end < 0) end += (long long)len;
        if (start < 0) start = 0;
        if (end < start) end = start;
        if ((size_t)end > len) end = (long long)len;
        size_t n = (size_t)(end - start);
        Value r = value_list_literal(0, NULL);
        list_ensure(r.as.list, n);
        r.as.list->len = n;
        for (size_t i = 0; i < n; i++) {
            r.as.list->items[i] = value_clone(l->items[start + i]);
        }
        return r;
    }
    if (obj.tag == VAL_TUPLE) {
        Tuple* t = obj.as.tuple;
        size_t len = t->len;
        long long end = has_end ? value_to_index(*end_opt) : (long long)len;
        if (start < 0) start += (long long)len;
        if (end < 0) end += (long long)len;
        if (start < 0) start = 0;
        if (end < start) end = start;
        if ((size_t)end > len) end = (long long)len;
        size_t n = (size_t)(end - start);
        Value r = value_tuple_literal(0, NULL);
        if (n) {
            r.as.tuple->items = (Value*)realloc(r.as.tuple->items, n * sizeof(Value));
        }
        r.as.tuple->len = n;
        for (size_t i = 0; i < n; i++) {
            r.as.tuple->items[i] = value_clone(t->items[start + i]);
        }
        return r;
    }
    fprintf(stderr, "Type error: slicing unsupported type\n"); exit(1);
}

static Value value_list_append(Value obj, Value arg) {
    if (obj.tag != VAL_LIST) { fprintf(stderr, "append on non-list\n"); exit(1); }
    list_ensure(obj.as.list, obj.as.list->len + 1);
    obj.as.list->items[obj.as.list->len++] = value_clone(arg);
    Value r = value_clone(obj);
    return r;
}

static Value value_list_remove(Value obj, Value arg) {
    if (obj.tag != VAL_LIST) { fprintf(stderr, "remove on non-list\n"); exit(1); }
    List* l = obj.as.list;
    size_t pos = l->len;
    for (size_t i = 0; i < l->len; i++) {
        if (value_eq(l->items[i], arg)) { pos = i; break; }
    }
    if (pos == l->len) { fprintf(stderr, "value not found in list.remove\n"); exit(1); }
    value_free(l->items[pos]);
    for (size_t i = pos + 1; i < l->len; i++) {
        l->items[i - 1] = l->items[i];
    }
    l->len -= 1;
    Value r = value_clone(obj);
    return r;
}

static Value value_set_add(Value obj, Value arg) {
    if (obj.tag != VAL_SET) { fprintf(stderr, "add on non-set\n"); exit(1); }
    Set* s = obj.as.setv;
    if (!set_contains(s, arg)) {
        set_ensure(s, s->len + 1);
        s->entries[s->len].used = 1;
        s->entries[s->len].key = value_clone(arg);
        s->len += 1;
    }
    return value_clone(obj);
}

static void value_file_close(Value v) {
    if (v.tag != VAL_FILE || !v.as.file) return;
    if (!v.as.file->closed && v.as.file->handle) {
        fclose(v.as.file->handle);
        v.as.file->closed = 1;
        v.as.file->handle = NULL;
    }
}

static void value_with_close(Value v) {
    if (v.tag == VAL_FILE) {
        value_file_close(v);
    }
}

static Value value_dict_keys(Value obj) {
    if (obj.tag != VAL_DICT) { fprintf(stderr, "keys on non-dict\n"); exit(1); }
    Dict* d = obj.as.dict;
    Value res = value_list_literal(0, NULL);
    if (d) {
        list_ensure(res.as.list, d->len);
        for (size_t i = 0; i < d->len; i++) {
            if (d->entries[i].used) {
                list_ensure(res.as.list, res.as.list->len + 1);
                res.as.list->items[res.as.list->len++] = value_clone(d->entries[i].key);
            }
        }
    }
    return res;
}

static Value value_dict_items(Value obj) {
    if (obj.tag != VAL_DICT) { fprintf(stderr, "items on non-dict\n"); exit(1); }
    Dict* d = obj.as.dict;
    Value res = value_list_literal(0, NULL);
    if (d) {
        list_ensure(res.as.list, d->len);
        for (size_t i = 0; i < d->len; i++) {
            if (d->entries[i].used) {
                Value pair_items[2] = { value_clone(d->entries[i].key), value_clone(d->entries[i].value) };
                list_ensure(res.as.list, res.as.list->len + 1);
                res.as.list->items[res.as.list->len++] = value_tuple_literal(2, pair_items);
                value_free(pair_items[0]);
                value_free(pair_items[1]);
            }
        }
    }
    return res;
}

static Value value_iterable_to_list(Value v) {
    switch (v.tag) {
        case VAL_LIST:
            return value_clone(v);
        case VAL_TUPLE: {
            Tuple* t = v.as.tuple;
            Value res = value_list_literal(0, NULL);
            if (t) {
                list_ensure(res.as.list, t->len);
                res.as.list->len = t->len;
                for (size_t i = 0; i < t->len; i++) {
                    res.as.list->items[i] = value_clone(t->items[i]);
                }
            }
            return res;
        }
        case VAL_SET: {
            Set* s = v.as.setv;
            Value res = value_list_literal(0, NULL);
            if (s) {
                list_ensure(res.as.list, s->len);
                for (size_t i = 0; i < s->len; i++) {
                    if (s->entries[i].used) {
                        list_ensure(res.as.list, res.as.list->len + 1);
                        res.as.list->items[res.as.list->len++] = value_clone(s->entries[i].key);
                    }
                }
            }
            return res;
        }
        case VAL_DICT: {
            Dict* d = v.as.dict;
            Value res = value_list_literal(0, NULL);
            if (d) {
                list_ensure(res.as.list, d->len);
                for (size_t i = 0; i < d->len; i++) {
                    if (d->entries[i].used) {
                        list_ensure(res.as.list, res.as.list->len + 1);
                        res.as.list->items[res.as.list->len++] = value_clone(d->entries[i].key);
                    }
                }
            }
            return res;
        }
        case VAL_STR: {
            const char* s = v.as.s ? v.as.s : "";
            size_t len = strlen(s);
            Value res = value_list_literal(0, NULL);
            list_ensure(res.as.list, len);
            res.as.list->len = len;
            for (size_t i = 0; i < len; i++) {
                char buf[2] = { s[i], '\0' };
                res.as.list->items[i] = value_str(buf);
            }
            return res;
        }
        default:
            fprintf(stderr, "Type error: object is not iterable\n"); exit(1);
    }
}

static Value value_str_from_value(Value v) {
    switch (v.tag) {
        case VAL_STR: return value_clone(v);
        case VAL_INT: {
            int n = snprintf(NULL, 0, "%lld", v.as.i);
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "%lld", v.as.i);
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_FLOAT: {
            int n = snprintf(NULL, 0, "%g", v.as.f);
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "%g", v.as.f);
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_BOOL: {
            return value_str(v.as.b ? "True" : "False");
        }
        case VAL_LIST: {
            int n = snprintf(NULL, 0, "<list len=%zu>", v.as.list ? v.as.list->len : 0);
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "<list len=%zu>", v.as.list ? v.as.list->len : 0);
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_TUPLE: {
            int n = snprintf(NULL, 0, "<tuple len=%zu>", v.as.tuple ? v.as.tuple->len : 0);
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "<tuple len=%zu>", v.as.tuple ? v.as.tuple->len : 0);
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_DICT: {
            int n = snprintf(NULL, 0, "<dict size=%zu>", v.as.dict ? v.as.dict->len : 0);
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "<dict size=%zu>", v.as.dict ? v.as.dict->len : 0);
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_SET: {
            int n = snprintf(NULL, 0, "<set size=%zu>", v.as.setv ? v.as.setv->len : 0);
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "<set size=%zu>", v.as.setv ? v.as.setv->len : 0);
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_FILE: {
            int n = snprintf(NULL, 0, "<file %s>", (v.as.file && v.as.file->closed) ? "closed" : "open");
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "<file %s>", (v.as.file && v.as.file->closed) ? "closed" : "open");
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_FUNC: {
            Value r = value_str("<function>");
            return r;
        }
        case VAL_CLASS: {
            const char* nm = (v.as.cls && v.as.cls->name) ? v.as.cls->name : "<class>";
            int n = snprintf(NULL, 0, "<class %s>", nm);
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "<class %s>", nm);
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_INSTANCE: {
            const char* nm = (v.as.inst && v.as.inst->cls && v.as.inst->cls->name) ? v.as.inst->cls->name : "<instance>";
            int n = snprintf(NULL, 0, "<%s instance>", nm);
            char* buf = (char*)xmalloc((size_t)n + 1);
            snprintf(buf, (size_t)n + 1, "<%s instance>", nm);
            Value r = value_str("");
            free(r.as.s);
            r.as.s = buf;
            return r;
        }
        case VAL_BOUND: {
            Value r = value_str("<bound method>");
            return r;
        }
    }
    return value_str("");
}

static Value builtin_int(Value v) {
    switch (v.tag) {
        case VAL_INT: return v;
        case VAL_FLOAT: return value_int((long long)v.as.f);
        case VAL_BOOL: return value_int((long long)v.as.b);
        case VAL_STR: return value_int(atoll(v.as.s));
        default: return value_int(0);
    }
}

static Value builtin_float(Value v) {
    switch (v.tag) {
        case VAL_FLOAT: return v;
        case VAL_INT: return value_float((double)v.as.i);
        case VAL_BOOL: return value_float((double)v.as.b);
        case VAL_STR: return value_float(atof(v.as.s));
        default: return value_float(0.0);
    }
}

static Value builtin_str(Value v) {
    return value_str_from_value(v);
}

static Value value_func(FuncPtr ptr) {
    Function* f = (Function*)xmalloc(sizeof(Function));
    f->ptr = ptr;
    f->refs = 1;
    Value v; v.tag = VAL_FUNC; v.as.func = f; return v;
}

static Value value_class(const char* name) {
    Class* c = (Class*)xmalloc(sizeof(Class));
    size_t n = strlen(name);
    c->name = (char*)xmalloc(n + 1);
    memcpy(c->name, name, n + 1);
    c->methods = (Dict*)xmalloc(sizeof(Dict));
    c->methods->len = 0;
    c->methods->cap = 0;
    c->methods->entries = NULL;
    c->refs = 1;
    Value v; v.tag = VAL_CLASS; v.as.cls = c; return v;
}

static Value value_instance(Class* cls) {
    if (cls) cls->refs += 1;
    Instance* inst = (Instance*)xmalloc(sizeof(Instance));
    inst->cls = cls;
    inst->fields = (Dict*)xmalloc(sizeof(Dict));
    inst->fields->len = 0;
    inst->fields->cap = 0;
    inst->fields->entries = NULL;
    inst->refs = 1;
    Value v; v.tag = VAL_INSTANCE; v.as.inst = inst; return v;
}

static Value value_bound(Instance* inst, Value func) {
    if (!inst) { fprintf(stderr, "bound method missing instance\n"); exit(1); }
    inst->refs += 1;
    Bound* b = (Bound*)xmalloc(sizeof(Bound));
    b->inst = inst;
    b->func = value_clone(func);
    b->refs = 1;
    Value v; v.tag = VAL_BOUND; v.as.bound = b; return v;
}

static void class_add_method(Value cls, const char* name, Value func) {
    if (cls.tag != VAL_CLASS || !cls.as.cls) {
        fprintf(stderr, "class_add_method on non-class\n");
        exit(1);
    }
    Value key = value_str(name);
    dict_set(cls.as.cls->methods, key, func);
    value_free(key);
}

static Value builtin_open(Value path, Value mode) {
    if (path.tag != VAL_STR || mode.tag != VAL_STR) {
        fprintf(stderr, "open() expects (str, str)\n"); exit(1);
    }
    FILE* f = fopen(path.as.s, mode.as.s);
    if (!f) { fprintf(stderr, "failed to open %s\n", path.as.s); exit(1); }
    struct File* fh = (struct File*)xmalloc(sizeof(struct File));
    fh->handle = f;
    fh->closed = 0;
    fh->refs = 1;
    Value v; v.tag = VAL_FILE; v.as.file = fh; return v;
}

static Value builtin_range(size_t argc, Value* args) {
    if (argc < 1 || argc > 3) { fprintf(stderr, "range() expects 1 to 3 arguments\n"); exit(1); }
    long long start = 0, end = 0, step = 1;
    if (argc == 1) {
        start = 0;
        end = value_to_index(args[0]);
    } else if (argc == 2) {
        start = value_to_index(args[0]);
        end = value_to_index(args[1]);
    } else {
        start = value_to_index(args[0]);
        end = value_to_index(args[1]);
        step = value_to_index(args[2]);
    }
    if (step == 0) { fprintf(stderr, "range() arg 3 must not be zero\n"); exit(1); }
    size_t len = 0;
    if (step > 0) {
        for (long long i = start; i < end; i += step) len++;
    } else {
        for (long long i = start; i > end; i += step) len++;
    }
    Value res = value_list_literal(0, NULL);
    list_ensure(res.as.list, len);
    res.as.list->len = len;
    long long cur = start;
    for (size_t i = 0; i < len; i++) {
        res.as.list->items[i] = value_int(cur);
        cur += step;
    }
    return res;
}

static Value builtin_enumerate(Value iterable) {
    Value seq = value_iterable_to_list(iterable);
    Value res = value_list_literal(0, NULL);
    list_ensure(res.as.list, seq.as.list ? seq.as.list->len : 0);
    res.as.list->len = seq.as.list ? seq.as.list->len : 0;
    for (size_t i = 0; i < res.as.list->len; i++) {
        Value idx = value_int((long long)i);
        Value item = value_clone(seq.as.list->items[i]);
        Value pair_items[2] = { idx, item };
        res.as.list->items[i] = value_tuple_literal(2, pair_items);
        value_free(idx);
        value_free(item);
    }
    value_free(seq);
    return res;
}

static Value builtin_sorted(Value iterable, Value key, int has_key) {
    Value list = value_iterable_to_list(iterable);
    if (!list.as.list) return list;
    size_t len = list.as.list->len;
    Value* keys = NULL;
    if (has_key) {
        if (key.tag != VAL_FUNC) {
            fprintf(stderr, "sorted key must be function\n");
            exit(1);
        }
        keys = (Value*)xmalloc(len * sizeof(Value));
        for (size_t i = 0; i < len; i++) {
            Value arg = value_clone(list.as.list->items[i]);
            Value args_arr[1] = { arg };
            keys[i] = value_call(key, 1, args_arr);
            value_free(arg);
        }
    }
    for (size_t i = 0; i < len; i++) {
        for (size_t j = i + 1; j < len; j++) {
            int cmp = has_key ? value_lt(keys[j], keys[i]) : value_lt(list.as.list->items[j], list.as.list->items[i]);
            if (cmp) {
                Value tmp = list.as.list->items[i];
                list.as.list->items[i] = list.as.list->items[j];
                list.as.list->items[j] = tmp;
                if (has_key) {
                    Value kt = keys[i];
                    keys[i] = keys[j];
                    keys[j] = kt;
                }
            }
        }
    }
    if (has_key) {
        for (size_t i = 0; i < len; i++) value_free(keys[i]);
        free(keys);
    }
    return list;
}

static Value value_file_read(Value obj) {
    if (obj.tag != VAL_FILE || !obj.as.file) { fprintf(stderr, "read on non-file\n"); exit(1); }
    if (obj.as.file->closed || !obj.as.file->handle) { fprintf(stderr, "read on closed file\n"); exit(1); }
    FILE* f = obj.as.file->handle;
    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    if (len < 0) len = 0;
    fseek(f, 0, SEEK_SET);
    char* buf = (char*)xmalloc((size_t)len + 1);
    size_t read = fread(buf, 1, (size_t)len, f);
    buf[read] = '\0';
    Value r = value_str("");
    free(r.as.s);
    r.as.s = buf;
    return r;
}

static Value value_file_write(Value obj, Value arg) {
    if (obj.tag != VAL_FILE || !obj.as.file) { fprintf(stderr, "write on non-file\n"); exit(1); }
    if (obj.as.file->closed || !obj.as.file->handle) { fprintf(stderr, "write on closed file\n"); exit(1); }
    Value s = value_str_from_value(arg);
    fputs(s.as.s, obj.as.file->handle);
    value_free(s);
    return value_clone(obj);
}

static Value value_call(Value func, int argc, Value* args) {
    if (func.tag == VAL_BOUND) {
        if (!func.as.bound || !func.as.bound->func.as.func || !func.as.bound->func.as.func->ptr) {
            fprintf(stderr, "Type error: invalid bound method\n"); exit(1);
        }
        Value selfv; selfv.tag = VAL_INSTANCE; selfv.as.inst = func.as.bound->inst; if (selfv.as.inst) selfv.as.inst->refs += 1;
        int nargc = argc + 1;
        Value* nargs = (Value*)xmalloc(sizeof(Value) * (size_t)nargc);
        nargs[0] = selfv;
        for (int i = 0; i < argc; i++) {
            nargs[i + 1] = args[i];
        }
        Value r = func.as.bound->func.as.func->ptr(nargc, nargs);
        value_free(selfv);
        free(nargs);
        return r;
    }
    if (func.tag == VAL_CLASS) {
        if (!func.as.cls) { fprintf(stderr, "Type error: call on null class\n"); exit(1); }
        // construct instance and call __init__ if present
        Value inst = value_instance(func.as.cls);
        // find __init__
        Value key = value_str("__init__");
        Value init = value_int(0);
        int has_init = 0;
        for (size_t i = 0; i < func.as.cls->methods->len; i++) {
            if (func.as.cls->methods->entries[i].used && value_eq(func.as.cls->methods->entries[i].key, key)) {
                init = value_clone(func.as.cls->methods->entries[i].value);
                has_init = 1;
                break;
            }
        }
        value_free(key);
        if (has_init) {
            int nargc = argc + 1;
            Value* nargs = (Value*)xmalloc(sizeof(Value) * (size_t)nargc);
            Value selfv = value_clone(inst);
            nargs[0] = selfv;
            for (int i = 0; i < argc; i++) {
                nargs[i + 1] = args[i];
            }
            Value tmp = value_call(init, nargc, nargs);
            value_free(tmp);
            value_free(selfv);
            free(nargs);
            value_free(init);
        }
        return inst;
    }
    if (func.tag != VAL_FUNC || !func.as.func || !func.as.func->ptr) {
        fprintf(stderr, "Type error: call on non-function\n"); exit(1);
    }
    return func.as.func->ptr(argc, args);
}

static Value builtin_input(Value prompt) {
    if (prompt.tag != VAL_STR) {
        fprintf(stderr, "input() prompt must be string\n");
        exit(1);
    }
    fputs(prompt.as.s, stdout);
    char buf[1024];
    if (!fgets(buf, sizeof(buf), stdin)) {
        return value_str("");
    }
    size_t len = strlen(buf);
    if (len > 0 && buf[len - 1] == '\n') buf[len - 1] = '\0';
    return value_str(buf);
}

static void value_print(Value v) {
    switch (v.tag) {
        case VAL_INT: printf("%lld", v.as.i); break;
        case VAL_FLOAT: printf("%g", v.as.f); break;
        case VAL_STR: printf("%s", v.as.s); break;
        case VAL_BOOL: printf("%s", v.as.b ? "True" : "False"); break;
        default: {
            Value s = value_str_from_value(v);
            printf("%s", s.as.s);
            value_free(s);
            break;
        }
    }
}

static void exc_push(ExcFrame* f) {
    f->prev = exc_stack;
    exc_stack = f;
}

static void exc_pop(ExcFrame* f) {
    (void)f;
    if (exc_stack) {
        exc_stack = exc_stack->prev;
    }
}

static Value exc_get() {
    if (!exc_active) return value_str("<no exception>");
    return value_clone(exc_value);
}

static void exc_clear() {
    if (exc_active) {
        value_free(exc_value);
    }
    exc_active = 0;
}

static int exc_match_name(const char* name) {
    if (!exc_active) return 0;
    if (!name) return 1;
    if (exc_value.tag == VAL_STR && exc_value.as.s && strcmp(exc_value.as.s, name) == 0) {
        return 1;
    }
    Value s = value_str_from_value(exc_value);
    int match = (s.tag == VAL_STR && s.as.s && strcmp(s.as.s, name) == 0);
    value_free(s);
    return match;
}

static void exc_raise(Value v) {
    if (exc_active) {
        value_free(exc_value);
    }
    exc_value = v;
    exc_active = 1;
    if (!exc_stack) {
        fprintf(stderr, "Uncaught exception: ");
        value_print(exc_value);
        fprintf(stderr, "\n");
        exit(1);
    }
    longjmp(exc_stack->buf, 1);
}

static void exc_rethrow() {
    if (!exc_active) {
        fprintf(stderr, "No active exception to rethrow\n");
        exit(1);
    }
    if (!exc_stack) {
        fprintf(stderr, "Uncaught exception: ");
        value_print(exc_value);
        fprintf(stderr, "\n");
        exit(1);
    }
    longjmp(exc_stack->buf, 1);
}
